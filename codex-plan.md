# План действий Codex

## Этап A. Анализ существующей сцены
1. Изучить структуру текущей сцены.
   - `assets/scene.scene` содержит корневой `Canvas` с детьми: `Camera`, `Background`, `Busket`, `Spawner`, `UI`, дополнительный пустой узел.
   - `Canvas` уже оснащён `cc.Canvas`, `cc.UITransform`, `cc.Widget`; значит, глобальные размеры сцены завязаны на UI-координаты.
   - `Busket` (орфография из сцены) имеет `cc.UITransform` 96×64 и `cc.Sprite` (`bucket.png`), что подходит для связки с компонентом представления игрока.
   - `Spawner` пока содержит только `cc.UITransform`, поэтому Node можно использовать как точку генерации сущностей или якорь для фабрики.
2. Проверить свойства и компоненты префаба падающего объекта.
   - `assets/prefabs/FallingItem.prefab` представлен узлом со `cc.UITransform` (40×36) и `cc.Sprite`, без коллайдера, без пользовательских скриптов.
   - Спрайт по умолчанию — `fruits-atlas` кадр (`__uuid__` `57520716...`), планирую заменить динамическим назначением кадра из конфигурации.
   - Отсутствие коллайдера подразумевает, что физику будем реализовывать через расчёт пересечений AABB в ECS, а не через встроенную физику.
3. Сводка доступных UI-элементов.
   - Узел `UI` содержит `ScoreLabel`, `TimerLabel`, `LivesContainer` с тремя дочерними спрайтами `Life1-3`; все элементы оснащены `cc.Label` или `cc.Sprite`.
   - Планирую добавить отдельные компоненты-вьюхи для управления текстами и состоянием жизней, чтобы не обращаться напрямую к Label/Sprite из домена.
4. Текущая конфигурация TypeScript.
   - `tsconfig.json` теперь включает строгий набор опций: `noImplicitAny`, `esModuleInterop`, поддержка `DOM` библиотек, `baseUrl: src`.
   - Настройки `allowJs` и `skipLibCheck` оставлены пользователем — при реализации обеспечу совместимость (буду создавать исходники в `src`, убедюсь, что `temp/tsconfig.cocos.json` подтягивает strict-режимы).
   - Для DI на декораторах включены `experimentalDecorators`, `emitDecoratorMetadata`; потребуется глобальный импорт `reflect-metadata` в точке входа.
5. Подключённые зависимости.
   - `package.json` содержит `miniplex@^2.0.0`, `inversify@^7.10.4`, `reflect-metadata@^0.2.2` и dev-зависимости `@cocos/creator-types`, `typescript@^5.5.3`.
   - Есть `lint-staged` с `eslint` хуком — при добавлении файлов проверю, требуется ли настройка ESLint (в текущем этапе планирования не меняю).

## Этап B. Проектирование ECS-архитектуры
1. Список сущностей miniplex.
   - `Basket` — управляемая игроком корзина, одна сущность.
   - `FallingItem` — базовый тип для всех падающих объектов с компонентом `ItemKind` (fruit/hazard, конкретный идентификатор).
   - `TrajectoryAnchor` — служебные сущности для траекторий (например, параметры зигзага), прицепленные к FallingItem.
   - `GameTimer`, `ScoreTracker`, `LifeTracker` — неброские сущности-синглтоны в ECS, чтобы системы могли работать без обращения к глобалам.
   - `UISync` сущности для ScoreLabel, TimerLabel, LivesContainer (по одной на UI-элемент) с компонентами `LabelRef`, `LivesViewRef`.
2. Набор компонентов данных.
   - Все компоненты — простые структуры данных без методов; храним только состояние, а логику выносим в системы.
   - `Position` (Vec2), `Velocity` (Vec2), `Acceleration` (Vec2) для движений.
   - `Bounds` (width/height/anchor) для расчёта пересечений с корзиной и границами.
   - `Trajectory` (тип + параметры: например, амплитуда, период, ускорение).
   - `SpawnConfig` (время до спавна, drop rate) на системе генерации.
   - `ItemKind` (enum `Fruit`, `Hazard`, `PowerUp` на будущее; конкретное имя ресурса).
   - `ScoreValue`, `LifeCost` для последствий поимки.
   - `Lifetime` (для удаления когда ушёл за экран) и `DespawnFlag`.
   - `SpriteRef` (cc.Node/cc.Sprite) для связи с представлением.
   - `InputTarget` на сущности корзины, чтобы система ввода знала, куда писать позицию.
3. Системы и обязанности.
   - Каждая система — чистая функция, которая читает/мутирует только те компоненты, на которые подписана query; никаких побочных эффектов вне своего контура.
   - `InputSystem` — обновляет компоненты `Velocity/DesiredPosition` корзины по текущему положению мыши.
   - `SpawnSystem` — управляет расписанием появления сущностей на основе конфигурации сложности, создаёт новые сущности строго через `world.create`.
   - `TrajectorySystem` — пересчитывает `Velocity` объектов в зависимости от их траектории (line, zigzag, accelerating) и модифицирует только свой набор компонентов.
   - `MovementSystem` — интеграция положения с учётом `deltaTime`, обработка выхода за нижнюю границу (ставит `DespawnFlag`).
   - `CollisionSystem` — проверяет пересечения `FallingItem` с `Basket`; записывает результат столкновения в компоненты-сигналы (`CollisionEvent`) вместо прямого вызова доменных сервисов.
   - `OutcomeSystem` (Score/Life) — считывает `CollisionEvent`, вызывает доменные сервисы и очищает компонент события.
   - `TimerSystem` — уменьшает время, при завершении ставит компонент `GameOverTrigger`.
   - `CleanupSystem` — удаляет сущности по `DespawnFlag`, синхронизирует destroy префабов, не выполняет бизнес-логики.
   - `UISyncSystem` — считывает актуальные данные домена и обновляет `LabelRef`, `LivesViewRef` через адаптеры.
4. Порядок и события.
   - Порядок внутри игрового цикла: `TimerSystem` → `InputSystem` → `SpawnSystem` → `TrajectorySystem` → `MovementSystem` → `CollisionSystem` → `OutcomeSystem` → `CleanupSystem` → `UISyncSystem`.
   - Внутренние события: `ItemSpawned`, `CollisionEvent`, `ItemMissed`, `LifeLost`, `GameOver`. Реализую через компоненты-сигналы или отдельный `EventQueue` в ECS, что соответствует best practice (никаких прямых вызовов между системами).

## Этап C. Доменная логика и API
1. Доменные сервисы.
   - `GameState` интерфейс со свойствами `score`, `lives`, `timeLeft`, `status`, `comboState`.
   - `ScoreService` с методами `add(points, itemId)`, `resetCombo()`, `incrementCombo()`.
   - `LifeService` с методами `lose(amount)`, `gain(amount)`, генерацией сигналов для UI.
   - `TimerService` с методами `start(duration)`, `tick(delta)`, `isExpired()`.
   - Доменные сервисы существуют вне ECS и предоставляются системам через инверсию зависимостей (передаются в конструктор или контекст при инициализации), чтобы не нарушать принцип единственной ответственности.
   - Планирую использовать `inversify` как DI-контейнер: зарегистрирую интерфейсы сервисов, конфигурации и адаптеры, после чего буду передавать их системам и представлению через внедрение зависимостей; это упрощает тестирование и подмену реализаций.
2. Обмен данными между ECS и доменом.
   - Системы не вызывают доменные сервисы напрямую; они выставляют компоненты-события, а отдельные медиаторы (например, `OutcomeSystem`) уже делегируют в домен.
   - Домен генерирует события (`ScoreChanged`, `LivesChanged`, `TimerChanged`, `GameStatusChanged`) через наблюдателей/подписчиков, которые слушает слой представления/UISyncSystem.
   - Данные конфигурации доступны обеим сторонам через `GameConfig` (иммутабельный объект, передаётся при инициализации).
3. Базовые игровые параметры.
   - Начальный запас жизней: 3.
   - Продолжительность сессии: 90 секунд (пригодно для демонстрации; сделаю конфигurable).
   - Очки: яблоко 10, банан 15, апельсин 20; опасный объект (`mushroom`) отнимает 1 жизнь и -20 очков (в пределах 0).
   - Планирую добавить коэффициент увеличения скорости/спавна каждые 20 секунд.
4. Конфигурации объектов и траекторий.
   - `GameConfig.items`: массив ресурсов `{ id, spriteFrame, score, danger, trajectories }`.
   - `GameConfig.trajectories`: словарь функций-строителей (line, zigzag, accelerate) с параметрами (`speed`, `amplitude`, `frequency`, `accelY`).
   - Настройки сложности и частоты спавна вынесу в `DifficultyCurve`, где прогресс по времени возвращает `spawnInterval`, `hazardChance`, `speedMultiplier`.

## Этап D. Слой представления (Cocos)
1. Компонент-прослойка.
   - Создам `GameController` (Cocos компонент) на `Canvas`, отвечающий за инициализацию ECS, передачу `deltaTime` и управление жизнью префабов.
   - Для каждого визуального узла (например, корзина) добавлю `EntityView` компонент, который регистрирует Node в ECS как `SpriteRef` и не реализует бизнес-логику (только связывание данных).
2. Обработка ввода мыши.
   - Использую `input.on(Input.EventType.MOUSE_MOVE)` для получения позиции курсора.
   - Позицию конвертирую в координаты Canvas (`UITransform.convertToNodeSpaceAR`), клемлю в пределах игрового поля и записываю в компонент `Position` корзины.
   - Предусмотрю поддержку касаний (`TOUCH_MOVE`) для мобильных устройств, чтобы архитектура была расширяема.
3. Модель обновления UI.
   - `ScoreView`, `TimerView`, `LivesView` компоненты подписываются на сигналы доменного слоя или получают данные через `UISyncSystem`.
   - Для жизней реализую `LivesView` с перебором спрайтов (`Life1-3`) и состоянием активности.
4. Создание визуальных объектов.
   - `PrefabFactory` компонент с ссылкой на `FallingItem` префаб и пулом инстансов (ObjectPool) для переиспользования.
   - При `ItemSpawned` фабрика отдаёт Node, привязывает к ECS-сущности, при `Despawn` возвращает в пул.
   - Компонент фабрики не будет хранить ссылок на сущности; связь осуществляется через компоненты `SpriteRef`, тем самым отделяя представление от логики.

## Этап E. Контент и игровые механики
1. Таблица типов объектов.
   - Фрукты: `apple` (`red-apple.png`), `banana` (`banana.png`), `orange` (`orange.png`) — базовый набор для MVP.
   - Опасный объект: `mushroom` (`mushroom.png`), отнимает жизнь, полезет в тот же префаб.
   - Расширяемость: в конфиг можно добавить любые спрайты из `fruits` каталога или power-ups.
2. Траектории.
   - `linear`: постоянная вертикальная скорость `vY`; горизонтальная скорость 0.
   - `zigzag`: вертикальное падение + горизонтальный offset `A * sin(ω * t + φ)`; параметры (`amplitude`, `frequency`) в конфиге.
   - `accelerating`: начальная скорость малая, к ней добавляется постоянное ускорение по Y и/или X.
   - Закладываю интерфейс `TrajectoryController` для добавления новых без изменения существующих систем.
3. Правила спавна.
   - Базовый интервал 1.2 с, уменьшается до 0.6 с с течением времени.
   - Вероятность опасного объекта стартует с 10%, растёт до 30%.
   - Каждые 20 с повышаем `speedMultiplier` на 10% для всех новых объектов.
4. Обратная связь.
   - При пойманном фрукте — вспышка/scale pop и короткий звук (если звуки не готовы, оставлю TODO + событие).
   - При опасном объекте — тряска корзины и инверсия цвета спрайта на короткое время.
   - UI-обратная связь: подсветка счёта при приросте, мигание жизней при потере.

## Этап F. Состояния игры и UX
1. Жизненный цикл игры.
   - `Ready` (ожидание начала) → `Playing` (таймер тикает) → `GameOver` (время вышло или жизни = 0).
   - На этапе `Ready` корзина фиксирована, спавн отключён; переход в `Playing` по нажатию кнопки или сразу при загрузке (configurable).
2. Данные экрана окончания.
   - Общий счёт, количество пойманных фруктов по типам, количество пойманных опасностей (для статистики).
   - В доменном слое храним `caughtByType` и `hazardsCaught`, чтобы легко построить отчёт.
3. Интеграция с UI-экранами.
   - На `UI` узле добавлю placeholder кнопок `Start`, `Restart` (можно скрыть/показать в зависимости от состояния).
   - `GameController` реагирует на события кнопок, меняет `GameState.status`, сбрасывает ECS, перезапускает таймер.
4. Пауза.
   - Предусмотрю `Paused` статус; при входе в паузу `TimerSystem` и `MovementSystem` пропускают обновление (используем флаг в домене).
   - В текущем MVP пауза может не иметь UI, но архитектура будет готова к добавлению.

## Этап G. Документация и контроль качества
1. Структура README.
   - `Overview`, `Requirements`, `Setup`, `Running the project`, `Architecture` (домен/ECS/представление), `Extensibility`, `Testing`, `Known limitations`.
   - В разделе `Architecture` добавлю диаграмму в текстовом виде (например, таблицу с описанием систем).
2. Чек-лист ручного тестирования.
   - Управление корзиной мышью (границы, отзывчивость).
   - Спавн объектов, корректность траекторий.
   - Начисление очков и отображение в UI.
   - Потеря жизни при поимке `mushroom`, окончание игры при 0 жизней/таймере.
3. Точки для будущих автоматизированных тестов.
   - Юнит-тесты конфигурации траекторий (расчёт смещения).
   - Тесты доменных сервисов (score/life/timer) без привязки к Cocos.
   - Симуляция спавна и столкновений в headless окружении (потенциально jest + ts-node).
4. Ограничения и идеи развития.
   - Добавление power-ups, мультислойных фонов, адаптивной сложности на основе успехов игрока.
   - Онлайн-таблица лидеров, сохранение прогресса.
   - Поддержка тач-управления и контроллеров.
5. Контроль следования принципам ECS.
   - Проверка, что компоненты остаются простыми структурами данных.
   - Валидация, что каждая система имеет одну ответственность и взаимодействует с сущностями только через queries.
   - Убедиться, что кросс-слойная коммуникация идёт через события/адаптеры, без прямых ссылок между системами и UI.
6. Интеграция DI.
   - Определить точку входа (например, `GameController`), где собирается `Container` из `inversify`, регистрирующий сервисы, конфиги и фабрики.
   - При необходимости подмены (тесты, альтернативные правила) реализовать интерфейсы и регистрировать разные реализации в контейнере `inversify`.
   - Использовать DI для передачи адаптеров в `UISyncSystem`, что позволит изолировать его от конкретных компонентов Cocos; не забыть однократно импортировать `reflect-metadata` до инициализации контейнера.
