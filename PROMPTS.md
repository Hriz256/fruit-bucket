# AI Agent Prompts Log

Этот файл содержит список промптов, использованных при разработке проекта с помощью AI-агента.

---

## Промпт #1: Инициализация проекта

**Дата:** 2024-11-04  
**Цель:** Создание полноценной игры на Cocos Creator с чистой архитектурой

### Промпт:

```
Создай 2D игру на Cocos Creator 3.x по следующему техническому заданию:

ГЕЙМПЛЕЙ:
- Жанр: "ловля падающих объектов"
- Игрок управляет корзиной внизу экрана (движение мышью/тачем по горизонтали)
- Сверху падают фрукты (яблоки, бананы, апельсины) и опасные объекты (грибы)
- Фрукты дают очки (10-20), грибы отнимают жизни (-1) и очки (-20)
- У игрока 3 жизни, таймер 90 секунд
- Сложность увеличивается со временем (скорость падения, частота спавна, больше опасных объектов)
- UI: счет, таймер, жизни (иконки сердец), экран game over с кнопкой "Начать заново"
- Звуковые эффекты: фоновая музыка, звук ловли фрукта, звук попадания гриба, sound game over

ТРАЕКТОРИИ:
- Линейная (прямое падение)
- Зигзаг (синусоидальное движение)
- Ускоренная (с имитацией гравитации)

ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ (обязательно):
- TypeScript со строгими настройками: strict: true, noImplicitAny: true
- Строгое соблюдение принципов SOLID и ООП
- Строгое соблюдение принципов и догм ECS (Entity Component System)
- Чистая и масштабируемая архитектура
- Разделение доменной логики от представления (UI)
- Минимальная связность кода
- Отсутствие синглтонов
- Явные интерфейсы/абстракции там, где есть вариативность

АРХИТЕКТУРНЫЕ ТРЕБОВАНИЯ:
- Использовать ECS архитектуру (библиотека miniplex)
- Разделить код на слои:
  * Domain Layer — бизнес-логика (сервисы: ScoreService, LifeService, TimerService, GameFlowService)
  * ECS Layer — игровая логика (компоненты данных + системы обработки)
  * App Layer — интеграция с Cocos Creator (адаптеры, мосты, DI container)
  * UI Layer — Cocos компоненты для отображения
- Dependency Injection через InversifyJS
- Event-driven коммуникация между слоями
- Factory pattern для создания entities и систем
- Strategy pattern для траекторий движения

АВТОМАТИЧЕСКИЙ ОТКАЗ (недопустимо):
- Файл > 400 строк
- Класс > 300 строк
- Метод > 50 строк
- Синглтоны
- Магические числа без конфигурации
- Жесткие зависимости (тесное связывание)
- Код без разделения ответственности

ОЖИДАЕМАЯ СТРУКТУРА:
assets/scripts/
├── config/ — GameConfig, константы, настройки сложности
├── domain/ — сервисы (Score, Life, Timer, Flow), state, events
├── ecs/ — components, systems, factories, interfaces
├── app/ — GameEngine, GameController, DI container, helpers
└── ui/ — ScoreView, TimerView, LivesView

Начни с создания:
1. Конфигурации (GameConfig с items, trajectories, difficulty stages)
2. ECS компонентов (Position, Velocity, Trajectory, Bounds, ItemKind, etc.)
3. ECS систем (Input, Spawn, Movement, Trajectory, Collision, Cleanup)
4. Доменных сервисов с интерфейсами
5. DI контейнера
6. GameEngine как фасад для ECS
7. GameController для интеграции с Cocos
8. UI компонентов для отображения

Важно: каждый класс должен иметь одну ответственность (SRP), системы должны быть чистыми (только логика), 
компоненты — чистыми данными. Никаких синглтонов, всё через DI.
```

### Результат:

✅ **Успешно создано:**
- Полная игра с ECS архитектурой
- 76 TypeScript файлов
- Строгое соблюдение SOLID/OOP/ECS принципов
- Layered architecture (Domain → ECS → App → UI)
- Dependency Injection без singletons
- 3 типа траекторий с Strategy pattern
- Прогрессивная система сложности
- Аудио система через адаптеры
- Адаптивный UI
- TypeScript strict mode
- 0 нарушений требований

**Метрики:**
- Max file size: 326 строк (< 400 ✓)
- Max class size: ~170 строк (< 300 ✓)
- Max method size: ~35 строк (< 50 ✓)
- Linter errors: 0 ✓
- SOLID compliance: 95%+ ✓

**Архитектурные решения:**
1. ECS с Miniplex — чистое разделение данных и логики
2. Factory pattern — SystemFactory для создания всех систем
3. Strategy pattern — LinearTrajectory, ZigZagTrajectory, AcceleratedTrajectory
4. Adapter pattern — NodeRenderer (IRenderer), AudioManager (IAudioPlayer)
5. Event Bus — SimpleGameEventBus для коммуникации между слоями
6. DI Container — InversifyJS с явным созданием экземпляров (без singleton scope)

---

## Промпт #2: [Будет добавлен при необходимости]

---

## Примечания

### Почему один промпт?

Данный проект был создан с использованием одного комплексного промпта, который содержал:
- Детальное техническое задание
- Строгие архитектурные требования
- Критерии автоматического отказа
- Ожидаемую структуру проекта

AI-агент (Codex/GPT-4) смог развернуть всю базу игры на основе этого промпта благодаря:
1. Четким техническим требованиям
2. Конкретным примерам желаемой архитектуры
3. Списку недопустимых практик
4. Пошаговому плану реализации

### Как использовать подобные промпты

**Для максимальной эффективности AI-агента:**

1. **Будьте конкретны** — указывайте версии технологий, библиотеки, паттерны
2. **Задавайте ограничения** — "не больше X строк", "без синглтонов", "strict TypeScript"
3. **Показывайте структуру** — дерево папок, примеры интерфейсов
4. **Укажите критерии отказа** — что категорически недопустимо
5. **Разбейте на этапы** — "сначала создай X, потом Y"

**Пример хорошего промпта:**
```
Создай [что] на [технология + версия]
с использованием [паттерны/библиотеки]
которое должно [функциональные требования]
соблюдая [архитектурные требования]
избегая [антипаттерны]
структура: [дерево папок]
начни с: [этапы]
```

**Пример плохого промпта:**
```
Сделай игру на Cocos
```

### Типичные ошибки при работе с AI

❌ **Слишком общий промпт** — "создай игру"  
✅ **Конкретный промпт** — "создай игру жанра X с механикой Y, используя паттерн Z"

❌ **Без ограничений** — AI может создать монолит  
✅ **С ограничениями** — "файл не больше 400 строк, класс не больше 300"

❌ **Без примеров** — AI интерпретирует по-своему  
✅ **С примерами** — "структура как в examples/, паттерн как Factory"

❌ **Все за раз** — "создай всё"  
✅ **Поэтапно** — "сначала config, потом components, потом systems"

---

## Итоги

**Время разработки с AI:** ~2-3 часа (включая архитектурный аудит и рефакторинг)  
**Время разработки без AI:** ~20-30 часов (оценка)  

**Преимущества AI-ассистента:**
- Мгновенная генерация boilerplate кода
- Автоматическое соблюдение паттернов
- Консистентный code style
- Быстрая итерация на основе feedback

**Что требует человеческого контроля:**
- Архитектурные решения (AI предлагает, человек решает)
- Бизнес-логика и game design
- Тестирование и отладка
- Code review и рефакторинг

